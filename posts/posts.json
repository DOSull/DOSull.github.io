[
  {
    "path": "posts/2021-10-22-spatstat-idw/",
    "title": "Inverse distance weighted (IDW) interpolation using spatstat",
    "description": "One of the joys (ahem) of R spatial is moving data around between formats so\nyou can use the best packages for particular jobs. Here's an example using IDW\ninterpolation in spatstat",
    "author": [],
    "date": "2021-10-22",
    "categories": [],
    "contents": "\nLibraries\nLibraries are the usual suspects plus spatstat (duh) and maptools for some extra conversions. We also need terra for the data prep.\n\n\nlibrary(sf)\nlibrary(dplyr)\nlibrary(tmap)\nlibrary(spatstat)\nlibrary(maptools)\nlibrary(terra)\n\n\n\nIntroduction\nAs is often the case there is useful functionality in a package that doesn’t play nice with the core R-spatial packages. spatstat is really great for lots of things, but does not support sf and even needs a bit of persuading to handle sp data. Its implementation of IDW interpolation is nice however, so it’s nice to know how to use it. Whether or not you should ever use IDW is another question altogether, but we can worry about that some other time.\nData\nFirst we need a set of values to interpolate. I made a projected version of the R core dataset volcano which is a nice place to start.\n\n\nmaungawhau <-  rast(\"maungawhau.tif\")\n\n\n\nSome random control points and a study area\nWe can get a dataframe of random points on the surface using terra::spatSample. We’ll make this into a sf object as a starting point because that’s the most likely situation when you want to interpolate data (you will have an sf source).\n\n\npts <- maungawhau %>%\n  spatSample(500, xy = TRUE) %>%\n  st_as_sf(coords = c(\"x\", \"y\")) %>%\n  st_set_crs(2193) %>%\n  st_jitter(5)\n\n\n\nWe also need a spatial extent for the interpolation, so let’s just make a convex hull of the points\n\n\nspatial_extent <- pts %>%\n  st_union() %>%\n  st_convex_hull() %>%\n  st_sf()\n\n\n\nAnd just to see where we are at\n\n\ntm_shape(maungawhau) + \n  tm_raster() +\n  tm_shape(pts) + \n  tm_dots() + \n  tm_shape(spatial_extent) + \n  tm_borders() + \n  tm_layout(legend.outside = TRUE)\n\n\n\n\nMake the data into a spatstat point pattern\nspatstat has its own format for point patterns, including coordinates, marks (the values) and a window or owin (the spatial extent). It’s best to make the window first and then we can make the whole thing all at once. spatstat prefers sp objects, so we go via ‘Spatial’ to get a spatstat::owin object. maptools provides the conversion to an owin.\n\n\nW <- spatial_extent %>%\n  as(\"Spatial\") %>%\n  as(\"owin\")\n\n\n\nWe also need the control point coordinates\n\n\nxy <- pts %>%\n  st_coordinates() %>%\n  as_tibble()\n\n\n\nNow we can make a spatstat::ppp point pattern\n\n\npp <- ppp(x = xy$X, xy$Y, marks = pts$maungawhau, window = W)\nplot(pp)\n\n\n\n\nSuccess!\nA previous notebook showed an even quicker way to do this, but where the window will be formed from a bounding box (and where’s the fun in that?)\npts %>%\n  as(\"Spatial\") %>%\n  as.ppp()\nInterpolation\nIt’s easy from here. power is the inverse power applied to distances, and eps is the resolution in units of the coordinate system.\n\n\nresult <- idw(pp, power = 2, eps = 10)\nplot(result)\n\n\n\n\nThis is readily converted back to a terra raster for comparison with the original surface.\n\n\ninterpolation <- rast(result)\ncrs(interpolation) <- crs(maungawhau) # spatstat does not retain CRS information\n\nm1 <- tm_shape(maungawhau) + \n  tm_raster()\nm2 <- tm_shape(interpolation) +\n  tm_raster()\n\ntmap_arrange(m1, m2)\n\n\n\n\nLike I said, IDW is not necessarily a great interpolation method!\n\n\n\n",
    "preview": "posts/2021-10-22-spatstat-idw/distill-preview.png",
    "last_modified": "2021-10-22T01:13:59+13:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2021-10-21-kde/",
    "title": "Kernel density estimation in R spatial",
    "description": "Here's one way to do kernel density estimation in R spatial",
    "author": [],
    "date": "2021-10-21",
    "categories": [],
    "contents": "\nPackages\nThis requires a surprising number of moving parts (at least the way I did it):\n\n\nlibrary(sf)\nlibrary(tmap)\nlibrary(spatstat)\nlibrary(maptools)\nlibrary(raster)\nlibrary(RColorBrewer) # because default raster colours are horrible\nlibrary(dplyr)\n\n\n\nData\nThe data are some point data (Airbnb listings from here) and some polygon data (NZ census Statistical Area 2 data).\nLoad the data\n\n\npolys <- st_read(\"sa2.gpkg\")\n\n\nReading layer `sa2' from data source \n  `/home/osullid3/Documents/code/newwebsite/testing/_posts/2021-10-21-kde/sa2.gpkg' \n  using driver `GPKG'\nSimple feature collection with 78 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 1735096 ymin: 5419590 xmax: 1759041 ymax: 5443768\nProjected CRS: NZGD2000 / New Zealand Transverse Mercator 2000\n\npts <- st_read(\"abb.gpkg\")\n\n\nReading layer `abb' from data source \n  `/home/osullid3/Documents/code/newwebsite/testing/_posts/2021-10-21-kde/abb.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1254 features and 16 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 1742685 ymin: 5420357 xmax: 1755385 ymax: 5442630\nProjected CRS: NZGD2000 / New Zealand Transverse Mercator 2000\n\nAnd have a look\n\n\ntm_shape(polys) +\n  tm_polygons() + \n  tm_shape(pts) + \n  tm_dots()\n\n\n\n\nspatstat for density estimation\nThe best way I know to do density estimation in the R ecosystem is using the spatstat library’s specialisation of base R’s density function. That means converting the point data to a spatstat planar point pattern (ppp) object, which involves a couple of steps.\n\n\npts.ppp <- pts$geom %>% \n  as(\"Spatial\") %>% # we need to convert to sp as a bridge to spatstat\n  as.ppp()          # and this is what we need maptools for...\n\n\n\nA point pattern also needs a ‘window’, which we’ll make from the polygons.\n\n\npts.ppp$window <- polys %>%\n  st_union() %>%       # combine all the polygons into a single shape\n  as(\"Spatial\") %>%    # convert to sp\n  as.owin()            # convert to spatstat owin - again maptools...\n\n\n\nNow the kernel density\nWe need some bounding box info to manage the density estimation resolution\n\n\nbb <- st_bbox(polys)\ncellsize <- 100\nheight <- (bb$ymax - bb$ymin) / cellsize\nwidth <- (bb$xmax - bb$xmin) / cellsize\n\n\n\nNow we specify the size of the raster we want with dimyx (note the order, y then x) using height and width.\nWe can convert this directly to a raster, but have to supply a CRS which we pull from the original points input dataset. At the time of writing (August 2021) you’ll get a complaint about the New Zealand Geodetic Datum 2000 because recent changes in how projections and datums are handled are still working themselves out.\n\n\nkde <- density(pts.ppp, sigma = 500, dimyx = c(height, width)) %>%\n  raster(crs = st_crs(pts)$wkt) # a ppp has no CRS information\n\n\n\nLet’s see what we got\nWe can map this - the default colour ramp in raster is horrible, so use RColorBrewer::brewer.pal to get something nicer.\n\n\ntm_shape(kde) +\n  tm_raster(palette = brewer.pal(9, \"Reds\"))\n\n\n\n\nA fallback sanity check\nTo give us an alternative view of the data, let’s just count points in polygons\n\n\npolys$n <- polys %>%\n  st_contains(pts) %>%\n  lengths()\n\n\n\nAnd map the result\n\n\ntm_shape(polys) +\n  tm_polygons(col = \"n\", palette = \"Reds\", title = \"Points in polygons\")\n\n\n\n\nAggregate the density surface pixels to polygons\nThis isn’t at all necessary, but is also useful to know. This is also a relatively slow operation. Note that we add together the density estimates in the pixels contained by each polygon.\n\n\nsummed_densities <- raster::extract(kde, polys, fun = sum)\n\n\n\nAppend this to the polygons and rescale so the result is an estimate of the original count. We multiply by cellsize^2 because each cell contains an estimate of the per sq metre (in this case, but per sq distance unit in general) density, so multiplying by the area of the cells gives an estimated count.\n\n\npolys$estimated_count = summed_densities[, 1] * cellsize ^ 2\n\n\n\nAnd now we can make another map\n\n\ntm_shape(polys) + \n  tm_polygons(col = \"estimated_count\", palette = \"Reds\", title = \"500m KDE estimate\")\n\n\n\n\n\n\n\n",
    "preview": "posts/2021-10-21-kde/distill-preview.png",
    "last_modified": "2021-10-22T01:03:55+13:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2021-10-20-random-even-points-on-the-globe/",
    "title": "Uniform random points on the globe",
    "description": "There isn't as much land near the poles, so how do you make uniform\nrandomly distributed points in lat-lng coordinate space. Here's how!",
    "author": [],
    "date": "2021-10-20",
    "categories": [],
    "contents": "\nLibraries are the usual suspects plus rnaturalearth for basemap data\n\n\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(rnaturalearth)\nlibrary(dplyr)\n\nn <- 2500\n\n\n\nThe key thing to realise here is that random uniform numbers in both latitude and longitude will not be evenly distributed on Earth’s surface, because the meridians converge toward the poles. We can make two datasets to show this. First a naive set of randomly located points:\n\n\npts_naive <- data.frame(lon = runif(n) * 360 - 180,\n                        lat = runif(n) * 180 - 90,\n                        type = \"naive\")\n\n\n\nHere comes the science…\nAnd now a set where inserting a cosine correction ensures that the distribution of latitudes is appropriately more dense close to the equator:\n\n\npts_even <- data.frame(lon = runif(n) * 360 - 180,\n                       lat = acos(runif(n) * 2 - 1) * 180 / pi - 90,\n                       type = \"even\")\n\n\n\nCompare the latitude distributions\nWe can make up a combined data table and directly compare the distribution of the latitudes with a nice density plot. The increased representation of points in the mid-latitudes with the cosine correction is clear.\n\n\npts <- bind_rows(pts_naive, pts_even)\nggplot(pts) +\n  geom_density(aes(y = lat, fill = type), alpha = 0.5, lwd = 0) +\n  scale_fill_viridis_d()\n\n\n\n\nMake a map\nUse an equal-area projection to clearly see the problem geographically.\n\n\nw <- ne_countries(returnclass = \"sf\") %>%\n  st_transform(\"+proj=hammer\")\n\npts_sf <- pts %>%\n  st_as_sf(coords = 1:2, crs = 4326)\n\nggplot(w) + \n  geom_sf(fill = \"#cccccc\", colour = \"white\", lwd = 0.35) +\n  geom_sf(data = pts_sf, aes(colour = type), alpha = 0.35) +\n  scale_colour_viridis_d() +\n  theme_minimal()\n\n\n\n\nThe naively distributed points are clearly denser at the poles than they should be, where the cosine term in the ‘even’ points generation method makes them evenly distributed over the globe.\n\n\n\n",
    "preview": "posts/2021-10-20-random-even-points-on-the-globe/distill-preview.png",
    "last_modified": "2021-10-22T00:24:32+13:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  }
]
