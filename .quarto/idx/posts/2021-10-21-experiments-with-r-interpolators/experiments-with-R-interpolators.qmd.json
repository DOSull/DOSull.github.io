{"title":"Experiments with R interpolators","markdown":{"yaml":{"title":"Experiments with R interpolators","description":"Messing around with interpolating via a triangulation to apply coordinate\ntransformations\n","author":"David O'Sullivan","categories":["R","spatial"],"draft":false,"date":"04-02-2024"},"headingText":"Load libraries","containsRefs":false,"markdown":"\n\n\n```{r message=FALSE}\nlibrary(akima)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(sf)\n```\n\nThis notebook shows how we can use a set of paired 'control points' of a projection to interpolate unknown locations to that projection. The basic setup is a table of pairs of coordinate pairs $(x_1,y_1)$ and $(x_2,y_2)$ representing the same location in two different coordinate systems. Given this setup assuming that the projection is well-behaved with no serious 'breaks' we can form an empirical projection to estimate locations in one coordinate system for 'unknown' locations in the other. See, for example\n\n+ Gaspar J A, 2011, “Using Empirical Map Projections for Modeling Early Nautical Charts”, in _Advances in Cartography and GIScience_ Ed A Ruas (Springer Berlin Heidelberg), pp 227–247, http://link.springer.com/10.1007/978-3-642-19214-2_15\n\n## Get input datasets\n### The empirical projection\nThis file contains points on a global grid system, generated using the [dggridR](https://github.com/r-barnes/dggridR/) package. We can see the points in 'lat-lon' space below. Note how because this is a global grid system the points appear to 'thin out' towards the poles. This is an artifact of plotting the points in lat-lon, which is also explored in [this post](../2021-10-20-random-even-points-on-the-globe/).\n\n```{r}\nemp_proj <- read.csv(\"dgg-2432-no-offsets-p4-briesemeister.csv\")\nggplot(emp_proj) +\n  geom_point(aes(x = lon, y = lat), size = 0.05) +\n  coord_equal()\n```\n\nInspection of the data shows we have two sets of coordinates `lon`, `lat` and `x`, `y`.\n\n```{r}\nhead(emp_proj)\n```\n\nThis projection is [Briesemeister](https://www.map-projections.net/single-view/briesemeister-v2), which is an oblique form of the Hammer-Aitoff projection. See \n\n+ Briesemeister W, 1953, “A New Oblique Equal-Area Projection” _Geographical Review_ **43**(2) 260\n\nIt's possible to form this projection with a proj string, but it is not commonly supported in GIS, and who knows proj strings that well?! For the record, this is the string you are looking for:\n\n    +proj=ob_tran +o_proj=hammer +o_lat_p=45 +o_lon_p=-10 +lon_0=0 +R=6371007\n\n### A sample dataset\nWe also want a set of points to project, and what better than a world map. Note that we can only project points, so this is points along world coastlines, not polygons.\n\n```{r}\npts <- read.csv(\"world_better.csv\") %>%\n  dplyr::select(lon, lat)\n\n# sanity check with a map\nggplot(pts) + \n  geom_point(aes(x = lon, y = lat), size = 0.05) + \n  coord_equal()\n```\n\n## Triangles interpolator\nThere are many different ways we can do this kind of interpolation. The simplest is based on triangulation. This method is available in the package `interp` but also in `akima` which is **much** quicker. The output x and y coordinates are formed by interpolating as shown below. `x` and `y` are the known locations of the input coordinate, which here are the longitude and latitude in out empirical projection dataset `emp_proj`. The desired outputs are at the longitude and latitude coordinates in the world maps dataset `pts`. And we do the interpolation twice, once for the `x` coordinate and once for the `y` coordinate in our target projection.\n\n```{r warning=FALSE}\nx_out <- akima::interpp(x = emp_proj$lon, y = emp_proj$lat, z = emp_proj$x,\n                xo = pts$lon, yo = pts$lat)\ny_out <- akima::interpp(x = emp_proj$lon, y = emp_proj$lat, z = emp_proj$y,\n                xo = pts$lon, yo = pts$lat)\n```\n\nNow make up a results data table and map it. `akima` puts the result in a column `z` in its output.\n\n```{r}\nresult <- data.frame(x = x_out$z, y = y_out$z)\nggplot(result) + \n  geom_point(aes(x = x, y = y), size = 0.05) + \n  coord_equal()\n```\n\n## Apply the empirical projection's cut region\nWhat are those dots across the southern area of the map? These are points that happen to fall in triangles in the first coordinate system (i.e. lon-lat) where one corner of the triangle lies on a different side of a discontinuity in the projection than the other corners. We should avoid projecting points inside these triangles because they project (as we can see!) unreliably.\n\nFor the Briesemeister projection we know the precise location of this discontinuity, and have prepared a file delineating the 'cut' position. We can use this to remove points from the sample dataset that lie inside triangles that intersect the cut region.\n\nFirst, here is the discontinuity. Points close to or on this line could end up in very different parts of the projected output and so are 'unsafe' to project using our interpolation-based approximation.\n\n```{r}\ncut_sf <- st_read(\"briesemeister-cut.geojson\")\nggplot(cut_sf) + \n  geom_sf()\n```\n\nNow triangulate the empirical projection data points, and assemble a polygon from all those triangles that are intersected by the discontinuity.\n\n```{r}\n# make the cut region into a sf dataset\nemp_proj_sf <- emp_proj %>%\n  st_as_sf(coords = c(\"lon\", \"lat\")) %>%\n  st_set_crs(4326)\n\ntriangles <- emp_proj_sf %>%\n  st_union() %>%\n  st_triangulate() %>%   # triangulation of empirical projection points\n  st_cast() %>%\n  st_as_sf() \n\ncut_triangles <- triangles %>%\n  st_filter(cut_sf)\n\ncut_region_sf <- cut_triangles %>% \n  st_filter(cut_sf) %>%\n  st_union() %>%       \n  st_as_sf() \n```\n\nWe quite reasonably get a warning that triangulation doesn't really apply to geographical coordinates, but... `akima` did the interpolation by triangulating these points and it doesn't know it's unsafe (because it's not a geospatial package). It's not actually 'unsafe' as such in this case, because we aren't using the triangulation for its metric properties anyway. So... we ignore this warning and plot this to see what we are dealing with\n\n```{r}\nggplot(triangles) +\n  geom_sf(colour = \"grey\") + \n  geom_sf(data = cut_triangles, fill = \"grey\", colour = \"white\") +\n  geom_sf(data = cut_region_sf, fill = \"#00000000\", colour = \"black\") +\n  geom_sf(data = cut_sf, color = \"red\")\n```\n\nNow we use `st_disjoint` to remove points in the data to project that are inside the cut region.\n\n```{r}\npts_to_project_sp <- pts %>%\n  st_as_sf(coords = c(\"lon\", \"lat\")) %>%\n  st_set_crs(4326) %>%\n  st_filter(cut_region_sf, .predicate = st_disjoint) %>%\n  as(\"Spatial\")\n```\n\nThe last step converts the points to the `SpatialPointsDataFrame` format of the `sp` package, which `akima` can also work with:\n\n```{r}\n# we also need the empirical projection data in the sp format\nemp_proj_sp <- emp_proj_sf %>%\n  as(\"Spatial\")\n\nx <- akima::interpp(emp_proj_sp, z = c(\"x\"), xo = pts_to_project_sp, linear = TRUE)\ny <- akima::interpp(emp_proj_sp, z = c(\"y\"), xo = pts_to_project_sp, linear = TRUE)\n```\n\nA bit unexpectedly, `akima` outputs the data to a two column dataframe with the interpolated values in a column with the same name as the input data, so getting the results into a final output table is as below.\n\n```{r}\nresult <- data.frame(x = x$x, y = y$y)\nggplot(result) +\n  geom_point(aes(x = x, y = y), size = 0.05) + \n  coord_equal()\n```\n\nAnd those rogue dots are all gone!\n","srcMarkdownNoYaml":"\n\n## Load libraries\n\n```{r message=FALSE}\nlibrary(akima)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(sf)\n```\n\nThis notebook shows how we can use a set of paired 'control points' of a projection to interpolate unknown locations to that projection. The basic setup is a table of pairs of coordinate pairs $(x_1,y_1)$ and $(x_2,y_2)$ representing the same location in two different coordinate systems. Given this setup assuming that the projection is well-behaved with no serious 'breaks' we can form an empirical projection to estimate locations in one coordinate system for 'unknown' locations in the other. See, for example\n\n+ Gaspar J A, 2011, “Using Empirical Map Projections for Modeling Early Nautical Charts”, in _Advances in Cartography and GIScience_ Ed A Ruas (Springer Berlin Heidelberg), pp 227–247, http://link.springer.com/10.1007/978-3-642-19214-2_15\n\n## Get input datasets\n### The empirical projection\nThis file contains points on a global grid system, generated using the [dggridR](https://github.com/r-barnes/dggridR/) package. We can see the points in 'lat-lon' space below. Note how because this is a global grid system the points appear to 'thin out' towards the poles. This is an artifact of plotting the points in lat-lon, which is also explored in [this post](../2021-10-20-random-even-points-on-the-globe/).\n\n```{r}\nemp_proj <- read.csv(\"dgg-2432-no-offsets-p4-briesemeister.csv\")\nggplot(emp_proj) +\n  geom_point(aes(x = lon, y = lat), size = 0.05) +\n  coord_equal()\n```\n\nInspection of the data shows we have two sets of coordinates `lon`, `lat` and `x`, `y`.\n\n```{r}\nhead(emp_proj)\n```\n\nThis projection is [Briesemeister](https://www.map-projections.net/single-view/briesemeister-v2), which is an oblique form of the Hammer-Aitoff projection. See \n\n+ Briesemeister W, 1953, “A New Oblique Equal-Area Projection” _Geographical Review_ **43**(2) 260\n\nIt's possible to form this projection with a proj string, but it is not commonly supported in GIS, and who knows proj strings that well?! For the record, this is the string you are looking for:\n\n    +proj=ob_tran +o_proj=hammer +o_lat_p=45 +o_lon_p=-10 +lon_0=0 +R=6371007\n\n### A sample dataset\nWe also want a set of points to project, and what better than a world map. Note that we can only project points, so this is points along world coastlines, not polygons.\n\n```{r}\npts <- read.csv(\"world_better.csv\") %>%\n  dplyr::select(lon, lat)\n\n# sanity check with a map\nggplot(pts) + \n  geom_point(aes(x = lon, y = lat), size = 0.05) + \n  coord_equal()\n```\n\n## Triangles interpolator\nThere are many different ways we can do this kind of interpolation. The simplest is based on triangulation. This method is available in the package `interp` but also in `akima` which is **much** quicker. The output x and y coordinates are formed by interpolating as shown below. `x` and `y` are the known locations of the input coordinate, which here are the longitude and latitude in out empirical projection dataset `emp_proj`. The desired outputs are at the longitude and latitude coordinates in the world maps dataset `pts`. And we do the interpolation twice, once for the `x` coordinate and once for the `y` coordinate in our target projection.\n\n```{r warning=FALSE}\nx_out <- akima::interpp(x = emp_proj$lon, y = emp_proj$lat, z = emp_proj$x,\n                xo = pts$lon, yo = pts$lat)\ny_out <- akima::interpp(x = emp_proj$lon, y = emp_proj$lat, z = emp_proj$y,\n                xo = pts$lon, yo = pts$lat)\n```\n\nNow make up a results data table and map it. `akima` puts the result in a column `z` in its output.\n\n```{r}\nresult <- data.frame(x = x_out$z, y = y_out$z)\nggplot(result) + \n  geom_point(aes(x = x, y = y), size = 0.05) + \n  coord_equal()\n```\n\n## Apply the empirical projection's cut region\nWhat are those dots across the southern area of the map? These are points that happen to fall in triangles in the first coordinate system (i.e. lon-lat) where one corner of the triangle lies on a different side of a discontinuity in the projection than the other corners. We should avoid projecting points inside these triangles because they project (as we can see!) unreliably.\n\nFor the Briesemeister projection we know the precise location of this discontinuity, and have prepared a file delineating the 'cut' position. We can use this to remove points from the sample dataset that lie inside triangles that intersect the cut region.\n\nFirst, here is the discontinuity. Points close to or on this line could end up in very different parts of the projected output and so are 'unsafe' to project using our interpolation-based approximation.\n\n```{r}\ncut_sf <- st_read(\"briesemeister-cut.geojson\")\nggplot(cut_sf) + \n  geom_sf()\n```\n\nNow triangulate the empirical projection data points, and assemble a polygon from all those triangles that are intersected by the discontinuity.\n\n```{r}\n# make the cut region into a sf dataset\nemp_proj_sf <- emp_proj %>%\n  st_as_sf(coords = c(\"lon\", \"lat\")) %>%\n  st_set_crs(4326)\n\ntriangles <- emp_proj_sf %>%\n  st_union() %>%\n  st_triangulate() %>%   # triangulation of empirical projection points\n  st_cast() %>%\n  st_as_sf() \n\ncut_triangles <- triangles %>%\n  st_filter(cut_sf)\n\ncut_region_sf <- cut_triangles %>% \n  st_filter(cut_sf) %>%\n  st_union() %>%       \n  st_as_sf() \n```\n\nWe quite reasonably get a warning that triangulation doesn't really apply to geographical coordinates, but... `akima` did the interpolation by triangulating these points and it doesn't know it's unsafe (because it's not a geospatial package). It's not actually 'unsafe' as such in this case, because we aren't using the triangulation for its metric properties anyway. So... we ignore this warning and plot this to see what we are dealing with\n\n```{r}\nggplot(triangles) +\n  geom_sf(colour = \"grey\") + \n  geom_sf(data = cut_triangles, fill = \"grey\", colour = \"white\") +\n  geom_sf(data = cut_region_sf, fill = \"#00000000\", colour = \"black\") +\n  geom_sf(data = cut_sf, color = \"red\")\n```\n\nNow we use `st_disjoint` to remove points in the data to project that are inside the cut region.\n\n```{r}\npts_to_project_sp <- pts %>%\n  st_as_sf(coords = c(\"lon\", \"lat\")) %>%\n  st_set_crs(4326) %>%\n  st_filter(cut_region_sf, .predicate = st_disjoint) %>%\n  as(\"Spatial\")\n```\n\nThe last step converts the points to the `SpatialPointsDataFrame` format of the `sp` package, which `akima` can also work with:\n\n```{r}\n# we also need the empirical projection data in the sp format\nemp_proj_sp <- emp_proj_sf %>%\n  as(\"Spatial\")\n\nx <- akima::interpp(emp_proj_sp, z = c(\"x\"), xo = pts_to_project_sp, linear = TRUE)\ny <- akima::interpp(emp_proj_sp, z = c(\"y\"), xo = pts_to_project_sp, linear = TRUE)\n```\n\nA bit unexpectedly, `akima` outputs the data to a two column dataframe with the interpolated values in a column with the same name as the input data, so getting the results into a final output table is as below.\n\n```{r}\nresult <- data.frame(x = x$x, y = y$y)\nggplot(result) +\n  geom_point(aes(x = x, y = y), size = 0.05) + \n  coord_equal()\n```\n\nAnd those rogue dots are all gone!\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"experiments-with-R-interpolators.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.551","theme":"lux","title-block-banner":true,"title":"Experiments with R interpolators","description":"Messing around with interpolating via a triangulation to apply coordinate\ntransformations\n","author":"David O'Sullivan","categories":["R","spatial"],"draft":false,"date":"04-02-2024"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}