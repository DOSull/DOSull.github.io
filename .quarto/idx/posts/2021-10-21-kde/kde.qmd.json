{"title":"Kernel density estimation in R spatial","markdown":{"yaml":{"title":"Kernel density estimation in R spatial","description":"Here's one way to do kernel density estimation in R spatial\n","author":"David O'Sullivan","categories":["R","spatial"],"date":"04-02-2024"},"headingText":"Packages","containsRefs":false,"markdown":"\n\nThis requires a surprising number of moving parts (at least the way I did it):\n\n```{r message=FALSE}\nlibrary(sf)\nlibrary(tmap)\nlibrary(spatstat)\nlibrary(raster)\nlibrary(dplyr)\n```\n\n## Data\nThe data are some [point data](abb.gpkg?raw=true) (Airbnb listings from [here](http://insideairbnb.com/new-zealand/)) and some [polygon data](sa2.gpkg?raw=true) (NZ census Statistical Area 2 data).\n\n### Load the data\n\n```{r message = FALSE}\npolys <- st_read(\"sa2.gpkg\")\npts <- st_read(\"abb.gpkg\")\n```\n\nAnd have a look\n\n```{r}\ntm_shape(polys) +\n  tm_polygons() + \n  tm_shape(pts) + \n  tm_dots()\n```\n\n## `spatstat` for density estimation\nThe best way I know to do density estimation in the _R_ ecosystem is using the [`spatstat`](https://spatstat.org/) library's specialisation of base _R_'s `density` function. That means converting the point data to a `spatstat` planar point pattern (`ppp`) object, which involves a couple of steps.\n\n```{r}\npts.ppp <- pts$geom %>% \n  as.ppp()\n```\n\nA point pattern also needs a 'window', which we'll make from the polygons.\n\n```{r}\npts.ppp$window <- polys %>%\n  st_union() %>%       # combine all the polygons into a single shape\n  as.owin()            # convert to spatstat owin - again maptools...\n```\n\n### Now the kernel density\nWe need some bounding box info to manage the density estimation resolution\n\n```{r}\nbb <- st_bbox(polys)\ncellsize <- 100\nheight <- (bb$ymax - bb$ymin) / cellsize\nwidth <- (bb$xmax - bb$xmin) / cellsize\n```\n\nNow we specify the size of the raster we want with `dimyx` (note the order, y then x) using `height` and `width`. \n\nWe can convert this directly to a raster, but have to supply a CRS which we pull from the original points input dataset. At the time of writing (August 2021) you'll get a complaint about the New Zealand Geodetic Datum 2000 because recent changes in how projections and datums are handled are still working themselves out.\n\n```{r}\nkde <- density(pts.ppp, sigma = 500, dimyx = c(height, width)) %>%\n  raster() \ncrs(kde) = st_crs(pts)$wkt  # a ppp has no CRS information so add it\n```\n\n### Let's see what we got\nWe can map this using `tmap`.\n\n```{r}\ntm_shape(kde) +\n  tm_raster(palette =  \"Reds\")\n```\n\n### A fallback sanity check\nTo give us an alternative view of the data, let's just count points in polygons\n\n```{r}\npolys$n <- polys %>%\n  st_contains(pts) %>%\n  lengths()\n```\n\nAnd map the result\n\n```{r}\ntm_shape(polys) +\n  tm_polygons(col = \"n\", palette = \"Reds\", title = \"Points in polygons\")\n```\n\n### Aggregate the density surface pixels to polygons\nThis isn't at all necessary, but is also useful to know. This is also a relatively slow operation. Note that we add together the density estimates in the pixels contained by each polygon.\n\n```{r}\nsummed_densities <- raster::extract(kde, polys, fun = sum)\n```\n\nAppend this to the polygons and rescale so the result is an estimate of the original count. We multiply by `cellsize^2` because each cell contains an estimate of the per sq metre (in this case, but per sq distance unit in general) density, so multiplying by the area of the cells gives an estimated count.\n\n```{r}\npolys$estimated_count = summed_densities[, 1] * cellsize ^ 2\n```\n\nAnd now we can make another map\n\n```{r}\ntm_shape(polys) + \n  tm_polygons(col = \"estimated_count\", palette = \"Reds\",\n              title = \"500m KDE summed\")\n```\n\nSpot the deliberate mistake?! \n\nSomething doesn't seem quite right! What's with the large numbers in the large rural area to the west of the city? Thing is, you shouldn't really map count data like this, but should instead convert to densities. If we include that option in the `tm_polygons` function, then order is restored.\n\n```{r}\ntm_shape(polys) + \n  tm_polygons(col = \"estimated_count\", palette = \"Reds\", convert2density = TRUE,\n              title = \"500m KDE estimate\")\n```\n\nReally, this should be done with the earlier map of points in polygons too, so let's show all three side by side. `tmap_arrange` is nice for this, although it has trouble making legend title font sizes match, unless you do some creative renaming. I've also multiplied the KDE result by 1,000,000 to convert the density to listings per sq. km, and we can see that the three maps are comparable.\n\n```{r}\nm1 <- tm_shape(kde * 1000000) + \n  tm_raster(palette = \"Reds\", title = \"500m KDE\")\nm2 <- tm_shape(polys) + \n  tm_fill(col = \"n\", palette = \"Blues\", convert2density = TRUE,\n              title = \"Point density\")\nm3 <- tm_shape(polys) + \n  tm_fill(col = \"estimated_count\", palette = \"Greens\", convert2density = TRUE,\n              title = \"KDE summed\")\ntmap_arrange(m1, m2, m3, nrow = 1)\n```","srcMarkdownNoYaml":"\n\n## Packages\nThis requires a surprising number of moving parts (at least the way I did it):\n\n```{r message=FALSE}\nlibrary(sf)\nlibrary(tmap)\nlibrary(spatstat)\nlibrary(raster)\nlibrary(dplyr)\n```\n\n## Data\nThe data are some [point data](abb.gpkg?raw=true) (Airbnb listings from [here](http://insideairbnb.com/new-zealand/)) and some [polygon data](sa2.gpkg?raw=true) (NZ census Statistical Area 2 data).\n\n### Load the data\n\n```{r message = FALSE}\npolys <- st_read(\"sa2.gpkg\")\npts <- st_read(\"abb.gpkg\")\n```\n\nAnd have a look\n\n```{r}\ntm_shape(polys) +\n  tm_polygons() + \n  tm_shape(pts) + \n  tm_dots()\n```\n\n## `spatstat` for density estimation\nThe best way I know to do density estimation in the _R_ ecosystem is using the [`spatstat`](https://spatstat.org/) library's specialisation of base _R_'s `density` function. That means converting the point data to a `spatstat` planar point pattern (`ppp`) object, which involves a couple of steps.\n\n```{r}\npts.ppp <- pts$geom %>% \n  as.ppp()\n```\n\nA point pattern also needs a 'window', which we'll make from the polygons.\n\n```{r}\npts.ppp$window <- polys %>%\n  st_union() %>%       # combine all the polygons into a single shape\n  as.owin()            # convert to spatstat owin - again maptools...\n```\n\n### Now the kernel density\nWe need some bounding box info to manage the density estimation resolution\n\n```{r}\nbb <- st_bbox(polys)\ncellsize <- 100\nheight <- (bb$ymax - bb$ymin) / cellsize\nwidth <- (bb$xmax - bb$xmin) / cellsize\n```\n\nNow we specify the size of the raster we want with `dimyx` (note the order, y then x) using `height` and `width`. \n\nWe can convert this directly to a raster, but have to supply a CRS which we pull from the original points input dataset. At the time of writing (August 2021) you'll get a complaint about the New Zealand Geodetic Datum 2000 because recent changes in how projections and datums are handled are still working themselves out.\n\n```{r}\nkde <- density(pts.ppp, sigma = 500, dimyx = c(height, width)) %>%\n  raster() \ncrs(kde) = st_crs(pts)$wkt  # a ppp has no CRS information so add it\n```\n\n### Let's see what we got\nWe can map this using `tmap`.\n\n```{r}\ntm_shape(kde) +\n  tm_raster(palette =  \"Reds\")\n```\n\n### A fallback sanity check\nTo give us an alternative view of the data, let's just count points in polygons\n\n```{r}\npolys$n <- polys %>%\n  st_contains(pts) %>%\n  lengths()\n```\n\nAnd map the result\n\n```{r}\ntm_shape(polys) +\n  tm_polygons(col = \"n\", palette = \"Reds\", title = \"Points in polygons\")\n```\n\n### Aggregate the density surface pixels to polygons\nThis isn't at all necessary, but is also useful to know. This is also a relatively slow operation. Note that we add together the density estimates in the pixels contained by each polygon.\n\n```{r}\nsummed_densities <- raster::extract(kde, polys, fun = sum)\n```\n\nAppend this to the polygons and rescale so the result is an estimate of the original count. We multiply by `cellsize^2` because each cell contains an estimate of the per sq metre (in this case, but per sq distance unit in general) density, so multiplying by the area of the cells gives an estimated count.\n\n```{r}\npolys$estimated_count = summed_densities[, 1] * cellsize ^ 2\n```\n\nAnd now we can make another map\n\n```{r}\ntm_shape(polys) + \n  tm_polygons(col = \"estimated_count\", palette = \"Reds\",\n              title = \"500m KDE summed\")\n```\n\nSpot the deliberate mistake?! \n\nSomething doesn't seem quite right! What's with the large numbers in the large rural area to the west of the city? Thing is, you shouldn't really map count data like this, but should instead convert to densities. If we include that option in the `tm_polygons` function, then order is restored.\n\n```{r}\ntm_shape(polys) + \n  tm_polygons(col = \"estimated_count\", palette = \"Reds\", convert2density = TRUE,\n              title = \"500m KDE estimate\")\n```\n\nReally, this should be done with the earlier map of points in polygons too, so let's show all three side by side. `tmap_arrange` is nice for this, although it has trouble making legend title font sizes match, unless you do some creative renaming. I've also multiplied the KDE result by 1,000,000 to convert the density to listings per sq. km, and we can see that the three maps are comparable.\n\n```{r}\nm1 <- tm_shape(kde * 1000000) + \n  tm_raster(palette = \"Reds\", title = \"500m KDE\")\nm2 <- tm_shape(polys) + \n  tm_fill(col = \"n\", palette = \"Blues\", convert2density = TRUE,\n              title = \"Point density\")\nm3 <- tm_shape(polys) + \n  tm_fill(col = \"estimated_count\", palette = \"Greens\", convert2density = TRUE,\n              title = \"KDE summed\")\ntmap_arrange(m1, m2, m3, nrow = 1)\n```"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"kde.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.551","theme":"lux","title-block-banner":true,"title":"Kernel density estimation in R spatial","description":"Here's one way to do kernel density estimation in R spatial\n","author":"David O'Sullivan","categories":["R","spatial"],"date":"04-02-2024"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}