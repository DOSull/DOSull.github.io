{"title":"Inverse distance weighted (IDW) interpolation using spatstat","markdown":{"yaml":{"title":"Inverse distance weighted (IDW) interpolation using spatstat","description":"One of the joys (ahem) of R spatial is moving data around between formats so\nyou can use the best packages for particular jobs. Here's an example using IDW\ninterpolation in spatstat\n","author":"David O'Sullivan","categories":["R","spatial"],"date":"04-02-2024"},"headingText":"Libraries","containsRefs":false,"markdown":"\n\nLibraries are the usual suspects plus `spatstat` (duh) and `maptools` for some extra conversions. We also need `terra` for the data prep.\n\n```{r message=FALSE}\nlibrary(sf)\nlibrary(dplyr)\nlibrary(tmap)\nlibrary(spatstat)\nlibrary(terra)\n```\n\n## Introduction\nAs is often the case there is useful functionality in a package that doesn't play nice with the core R-spatial packages. `spatstat` is really great for lots of things, but does not support `sf` and even needs a bit of persuading to handle `sp` data. Its implementation of IDW interpolation is nice however, so it's nice to know how to use it. Whether or not you should ever use IDW is another question altogether, but we can worry about that some other time.\n\n### Data\nFirst we need a set of values to interpolate. I made a projected version of the _R_ core dataset volcano which is a nice place to start.\n\n```{r}\nmaungawhau <-  rast(\"maungawhau.tif\")\n```\n\n### Some random control points and a study area\nWe can get a dataframe of random points on the surface using `terra::spatSample`. We'll make this into a `sf` object as a starting point because that's the most likely situation when you want to interpolate data (you will have an `sf` source).\n\n```{r}\npts <- maungawhau |>\n  spatSample(500, xy = TRUE) |>\n  st_as_sf(coords = c(\"x\", \"y\")) |>\n  st_set_crs(2193) |>\n  st_jitter(5)\n```\n\nWe also need a spatial extent for the interpolation, so let's just make a convex hull of the points\n\n```{r}\nspatial_extent <- pts |>\n  st_union() |>\n  st_convex_hull() |>\n  st_sf()\n```\n\nAnd just to see where we are at\n\n```{r}\ntm_shape(maungawhau) + \n  tm_raster() +\n  tm_shape(pts) + \n  tm_dots() + \n  tm_shape(spatial_extent) + \n  tm_borders() + \n  tm_layout(legend.outside = TRUE)\n```\n\n## Make the data into a `spatstat` point pattern\n`spatstat` has its own format for point patterns, including coordinates, marks (the values) and a window or `owin` (the spatial extent). It's best to make the window first and then we can make the whole thing all at once. `spatstat` prefers `sp` objects, so we go via 'Spatial' to get a `spatstat::owin` object. `maptools` provides the conversion to an `owin`.\n\n```{r}\nW <- spatial_extent |>\n  as.owin()\n```\n\nWe also need the control point coordinates\n\n```{r}\nxy <- pts |>\n  st_coordinates() |>\n  as_tibble()\n```\n\nNow we can make a `spatstat::ppp` point pattern\n\n```{r}\npp <- ppp(x = xy$X, xy$Y, marks = pts$maungawhau, window = W)\nplot(pp)\n```\n\nSuccess! \n\nA [previous notebook](../2021-10-21-kde/) showed an even quicker way to do this, but where the window will be formed from a bounding box (and where's the fun in that?)\n\n```\npts %>%\n  as(\"Spatial\") %>%\n  as.ppp()\n```\n\n## Interpolation\nIt's easy from here. `power` is the inverse power applied to distances, and `eps` is the resolution in units of the coordinate system.\n\n```{r}\nresult <- idw(pp, power = 2, eps = 10)\nplot(result)\n```\n\nThis is readily converted back to a `terra` raster for comparison with the original surface.\n\n```{r}\ninterpolation <- rast(result)\ncrs(interpolation) <- crs(maungawhau) # spatstat does not retain CRS information\n\nm1 <- tm_shape(maungawhau) + \n  tm_raster()\nm2 <- tm_shape(interpolation) +\n  tm_raster()\n\ntmap_arrange(m1, m2)\n```\n\nLike I said, IDW is not necessarily a great interpolation method!\n\n","srcMarkdownNoYaml":"\n\n## Libraries\nLibraries are the usual suspects plus `spatstat` (duh) and `maptools` for some extra conversions. We also need `terra` for the data prep.\n\n```{r message=FALSE}\nlibrary(sf)\nlibrary(dplyr)\nlibrary(tmap)\nlibrary(spatstat)\nlibrary(terra)\n```\n\n## Introduction\nAs is often the case there is useful functionality in a package that doesn't play nice with the core R-spatial packages. `spatstat` is really great for lots of things, but does not support `sf` and even needs a bit of persuading to handle `sp` data. Its implementation of IDW interpolation is nice however, so it's nice to know how to use it. Whether or not you should ever use IDW is another question altogether, but we can worry about that some other time.\n\n### Data\nFirst we need a set of values to interpolate. I made a projected version of the _R_ core dataset volcano which is a nice place to start.\n\n```{r}\nmaungawhau <-  rast(\"maungawhau.tif\")\n```\n\n### Some random control points and a study area\nWe can get a dataframe of random points on the surface using `terra::spatSample`. We'll make this into a `sf` object as a starting point because that's the most likely situation when you want to interpolate data (you will have an `sf` source).\n\n```{r}\npts <- maungawhau |>\n  spatSample(500, xy = TRUE) |>\n  st_as_sf(coords = c(\"x\", \"y\")) |>\n  st_set_crs(2193) |>\n  st_jitter(5)\n```\n\nWe also need a spatial extent for the interpolation, so let's just make a convex hull of the points\n\n```{r}\nspatial_extent <- pts |>\n  st_union() |>\n  st_convex_hull() |>\n  st_sf()\n```\n\nAnd just to see where we are at\n\n```{r}\ntm_shape(maungawhau) + \n  tm_raster() +\n  tm_shape(pts) + \n  tm_dots() + \n  tm_shape(spatial_extent) + \n  tm_borders() + \n  tm_layout(legend.outside = TRUE)\n```\n\n## Make the data into a `spatstat` point pattern\n`spatstat` has its own format for point patterns, including coordinates, marks (the values) and a window or `owin` (the spatial extent). It's best to make the window first and then we can make the whole thing all at once. `spatstat` prefers `sp` objects, so we go via 'Spatial' to get a `spatstat::owin` object. `maptools` provides the conversion to an `owin`.\n\n```{r}\nW <- spatial_extent |>\n  as.owin()\n```\n\nWe also need the control point coordinates\n\n```{r}\nxy <- pts |>\n  st_coordinates() |>\n  as_tibble()\n```\n\nNow we can make a `spatstat::ppp` point pattern\n\n```{r}\npp <- ppp(x = xy$X, xy$Y, marks = pts$maungawhau, window = W)\nplot(pp)\n```\n\nSuccess! \n\nA [previous notebook](../2021-10-21-kde/) showed an even quicker way to do this, but where the window will be formed from a bounding box (and where's the fun in that?)\n\n```\npts %>%\n  as(\"Spatial\") %>%\n  as.ppp()\n```\n\n## Interpolation\nIt's easy from here. `power` is the inverse power applied to distances, and `eps` is the resolution in units of the coordinate system.\n\n```{r}\nresult <- idw(pp, power = 2, eps = 10)\nplot(result)\n```\n\nThis is readily converted back to a `terra` raster for comparison with the original surface.\n\n```{r}\ninterpolation <- rast(result)\ncrs(interpolation) <- crs(maungawhau) # spatstat does not retain CRS information\n\nm1 <- tm_shape(maungawhau) + \n  tm_raster()\nm2 <- tm_shape(interpolation) +\n  tm_raster()\n\ntmap_arrange(m1, m2)\n```\n\nLike I said, IDW is not necessarily a great interpolation method!\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"spatstat-idw.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.551","theme":"lux","title-block-banner":true,"title":"Inverse distance weighted (IDW) interpolation using spatstat","description":"One of the joys (ahem) of R spatial is moving data around between formats so\nyou can use the best packages for particular jobs. Here's an example using IDW\ninterpolation in spatstat\n","author":"David O'Sullivan","categories":["R","spatial"],"date":"04-02-2024"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}