{"title":"Low level handling of sf objects","markdown":{"yaml":{"title":"Low level handling of sf objects","description":"You can handle sf objects at a low level but it can\ntake a bit of getting used to\n","author":"David O'Sullivan","categories":["R","spatial"],"draft":false,"date":"04-02-2024"},"headingText":"Packages","containsRefs":false,"markdown":"\n\n```{r setup, cache = F}\nknitr::opts_chunk$set(error = TRUE, message = TRUE)\n```\n\nEverything here needs just `sf` and `dplyr`.\n\n```{r message=FALSE}\nlibrary(sf)\nlibrary(dplyr)\n```\n\n## Making polygons\nMy main confusion dealing with polygons in `sf` sounds dumb, but was easily fixed. Matrices in *R* get populated by column, by default, where the points in a polygon are in the rows of the matrix (as they would be in a dataframe with x and y attributes). You just have to make sure to populate the matrices in the right order. \n\nThere's also the slightly strange fact that you have to wrap a matrix of points in a list to make a polygon. \n\nSo because of the row-column thing, there's a tendency to do\n\n```{r}\nmat <- matrix(c(0, 0,\n                1, 0,\n                1, 1,\n                0, 1,\n                0, 0), nrow = 5, ncol = 2)\nsquare <- st_polygon(list(mat))\n```\n\nBut that fails, because the matrix we made was\n\n```{r}\nmat\n```\n\nand the first and last rows don't match (even if they did, it's not actually a polygon!).\n\nBut specify that the matrix should be populated `byrow` and all is well\n\n```{r}\nsquare <- st_polygon(list(matrix(c(0, 0,\n                                   1, 0,\n                                   1, 1,\n                                   0, 1,\n                                   0, 0), nrow = 5, ncol = 2, byrow = TRUE)))\nplot(square)\n```\n\nIf you happen to have vectors of the x and y coordinates, then it's easier.\n\n```{r}\nx <- c(0, 1, 1, 0, 0)\ny <- c(0, 0, 1, 1, 0)\nsquare <- st_polygon(list(matrix(c(x, y), nrow = 5, ncol = 2)))\nplot(square)\n```\n\n## Floating point coordinates and their discontents\n`sf` defaults to using floating point calculations which has some annoying side-effects. For example, the code below results in an error\n\n```{r}\nangles <- 0:3 * 2 * pi / 3\nx <- cos(angles)\ny <- sin(angles)\ntriangle <- st_polygon(list(matrix(c(x, y), nrow = 7, ncol = 2)))\n```\n\nBecause `sf` defaults to floating point it doesn't consider the polygon closed due to precision issues that mean *R* considers `sin(0) != sin(2 * pi)`:\n\n```{r}\nsin(0) == sin(2 * pi)\n```\n\nThere is no easy way to fix this except to round the coordinates!\n\n```{r}\nx <- round(x, 6)\ny <- round(y, 6)\ntriangle <- st_polygon(list(matrix(c(x, y), nrow = 4, ncol = 2)))\nplot(triangle)\n```\n\nThere's not a lot you can do about this when you are constructing `sf` objects. Polygons must be closed, and equality is strictly applied to the opening and closing points. You can't ask `st_polygon` to automatically close polygons for you.\n\nOnce you have polygons to work with, the problem can come back to bite you, but there is a way around it. For example, this works OK:\n\n```{r}\nsquare %>% \n  st_difference(triangle) %>%\n  plot()\n```\n\nBut let's make two squares that are _theoretically_ adjacent to one another, but happen to have non-integer coordinates (which... is pretty commonplace!)\n\n```{r}\nangles <- seq(1, 7, 2) * 2 * pi / 8\nangles <- c(angles, angles[1])\nx1 <- cos(angles)\ny1 <- sin(angles)\n\ns1 <- st_polygon(list(matrix(c(x1, y1), nrow = 5, ncol = 2)))\nbb <- st_bbox(s1)\ns2 <- s1 + c(bb$xmax - bb$xmin, 0)\n\nplot(s1, xlim = c(-1, 2.1))\nplot(s2, add = TRUE)\n```\n\nTwo squares, next to one another as we might hope, but if, for example, we `st_union` them we get a MULTIPOLYGON.\n\n```{r}\ns3 <- st_union(s1, s2)\ns3\n```\n\nIf we plot them, they still appear separate\n\n```{r}\nplot(s3)\n```\n\nand if we measure the distance between them, turns out they don't touch at all, but are in fact a miniscule distance apart...\n\n```{r}\ns1 %>% st_distance(s2)\n```\n\nIt's probably not necessary to point out how silly this is, even if it is strictly correct.\n\n```{r}\nRXKCD::getXKCD(2170)$img\n```\n\n\n## Specifying precision for spatial operations\nBy contrast if we use `rgeos` functions the equivalent union operation works as we might expect (although we do have to feed `rgeos` the old `sp` types of polygon, which we can do via a call to `as(\"Spatial\")`...)\n\n```{r}\nrgeos::gUnion(as(s1, \"Spatial\"), as(s2, \"Spatial\")) %>%\n  st_as_sfc() %>%\n  plot()\n```\n\n`sf` does allow us to effectively emulate the `rgeos` behaviour, albeit not for simple geometries. When we instead bundle geometries up into feature collections, we can assign them a precision, and this will take care of the kinds of problems we see above:\n\n```{r}\ns1_sfc <- s1 %>% \n  st_sfc() %>%\n  st_set_precision(1e8)\ns2_sfc <- s2 %>% \n  st_sfc() %>%\n  st_set_precision(1e8)\n\ns1_sfc %>% \n  st_union(s2_sfc) %>%\n  plot()\n```\n\nThe first time I looked this up [in help](https://r-spatial.github.io/sf/reference/st_precision.html), I got it wrong [due to careless reading](https://github.com/r-spatial/sf/issues/1855), and, I think, assuming that the number you provide to `st_set_precision()` was a 'tolerance', or, in effect a 'snap distance'. The help is also a bit roundabout, and directs you to [this page](https://locationtech.github.io/jts/javadoc/org/locationtech/jts/geom/PrecisionModel.html), for an explanation of how it works. \n\nIn effect all coordinates are adjusted by applying a function like this one:\n\n```{r}\nadjust_precision <- function(x, precision) {\n  round(x * precision) / precision\n}\nsqrt(2) %>% adjust_precision(1000)\n```\n\n### `st_snap`\nAnother possible fix for the floating point issue is snapping points to the coordinates of another object before applying operations. So this works, although it is not as clean as the `st_precision` option. On the other hand, it does work on plain geometry objects, not only on those that have been bundled up into collections.\n\n```{r}\ns1 %>% st_snap(s2, 1e-8) %>%\n  st_union(s2) %>%\n  plot()\n```\n## In conclusion\nThe tools for making and manipulating geometries at a low level are available in `sf` but they are not always as simple as you'd like. Of course, most often you are dealing with datasets and that's where `sf` comes into its own. Just remember `st_set_precision()` and you should be able to avoid quite a few headaches...\n","srcMarkdownNoYaml":"\n\n```{r setup, cache = F}\nknitr::opts_chunk$set(error = TRUE, message = TRUE)\n```\n\n## Packages\nEverything here needs just `sf` and `dplyr`.\n\n```{r message=FALSE}\nlibrary(sf)\nlibrary(dplyr)\n```\n\n## Making polygons\nMy main confusion dealing with polygons in `sf` sounds dumb, but was easily fixed. Matrices in *R* get populated by column, by default, where the points in a polygon are in the rows of the matrix (as they would be in a dataframe with x and y attributes). You just have to make sure to populate the matrices in the right order. \n\nThere's also the slightly strange fact that you have to wrap a matrix of points in a list to make a polygon. \n\nSo because of the row-column thing, there's a tendency to do\n\n```{r}\nmat <- matrix(c(0, 0,\n                1, 0,\n                1, 1,\n                0, 1,\n                0, 0), nrow = 5, ncol = 2)\nsquare <- st_polygon(list(mat))\n```\n\nBut that fails, because the matrix we made was\n\n```{r}\nmat\n```\n\nand the first and last rows don't match (even if they did, it's not actually a polygon!).\n\nBut specify that the matrix should be populated `byrow` and all is well\n\n```{r}\nsquare <- st_polygon(list(matrix(c(0, 0,\n                                   1, 0,\n                                   1, 1,\n                                   0, 1,\n                                   0, 0), nrow = 5, ncol = 2, byrow = TRUE)))\nplot(square)\n```\n\nIf you happen to have vectors of the x and y coordinates, then it's easier.\n\n```{r}\nx <- c(0, 1, 1, 0, 0)\ny <- c(0, 0, 1, 1, 0)\nsquare <- st_polygon(list(matrix(c(x, y), nrow = 5, ncol = 2)))\nplot(square)\n```\n\n## Floating point coordinates and their discontents\n`sf` defaults to using floating point calculations which has some annoying side-effects. For example, the code below results in an error\n\n```{r}\nangles <- 0:3 * 2 * pi / 3\nx <- cos(angles)\ny <- sin(angles)\ntriangle <- st_polygon(list(matrix(c(x, y), nrow = 7, ncol = 2)))\n```\n\nBecause `sf` defaults to floating point it doesn't consider the polygon closed due to precision issues that mean *R* considers `sin(0) != sin(2 * pi)`:\n\n```{r}\nsin(0) == sin(2 * pi)\n```\n\nThere is no easy way to fix this except to round the coordinates!\n\n```{r}\nx <- round(x, 6)\ny <- round(y, 6)\ntriangle <- st_polygon(list(matrix(c(x, y), nrow = 4, ncol = 2)))\nplot(triangle)\n```\n\nThere's not a lot you can do about this when you are constructing `sf` objects. Polygons must be closed, and equality is strictly applied to the opening and closing points. You can't ask `st_polygon` to automatically close polygons for you.\n\nOnce you have polygons to work with, the problem can come back to bite you, but there is a way around it. For example, this works OK:\n\n```{r}\nsquare %>% \n  st_difference(triangle) %>%\n  plot()\n```\n\nBut let's make two squares that are _theoretically_ adjacent to one another, but happen to have non-integer coordinates (which... is pretty commonplace!)\n\n```{r}\nangles <- seq(1, 7, 2) * 2 * pi / 8\nangles <- c(angles, angles[1])\nx1 <- cos(angles)\ny1 <- sin(angles)\n\ns1 <- st_polygon(list(matrix(c(x1, y1), nrow = 5, ncol = 2)))\nbb <- st_bbox(s1)\ns2 <- s1 + c(bb$xmax - bb$xmin, 0)\n\nplot(s1, xlim = c(-1, 2.1))\nplot(s2, add = TRUE)\n```\n\nTwo squares, next to one another as we might hope, but if, for example, we `st_union` them we get a MULTIPOLYGON.\n\n```{r}\ns3 <- st_union(s1, s2)\ns3\n```\n\nIf we plot them, they still appear separate\n\n```{r}\nplot(s3)\n```\n\nand if we measure the distance between them, turns out they don't touch at all, but are in fact a miniscule distance apart...\n\n```{r}\ns1 %>% st_distance(s2)\n```\n\nIt's probably not necessary to point out how silly this is, even if it is strictly correct.\n\n```{r}\nRXKCD::getXKCD(2170)$img\n```\n\n\n## Specifying precision for spatial operations\nBy contrast if we use `rgeos` functions the equivalent union operation works as we might expect (although we do have to feed `rgeos` the old `sp` types of polygon, which we can do via a call to `as(\"Spatial\")`...)\n\n```{r}\nrgeos::gUnion(as(s1, \"Spatial\"), as(s2, \"Spatial\")) %>%\n  st_as_sfc() %>%\n  plot()\n```\n\n`sf` does allow us to effectively emulate the `rgeos` behaviour, albeit not for simple geometries. When we instead bundle geometries up into feature collections, we can assign them a precision, and this will take care of the kinds of problems we see above:\n\n```{r}\ns1_sfc <- s1 %>% \n  st_sfc() %>%\n  st_set_precision(1e8)\ns2_sfc <- s2 %>% \n  st_sfc() %>%\n  st_set_precision(1e8)\n\ns1_sfc %>% \n  st_union(s2_sfc) %>%\n  plot()\n```\n\nThe first time I looked this up [in help](https://r-spatial.github.io/sf/reference/st_precision.html), I got it wrong [due to careless reading](https://github.com/r-spatial/sf/issues/1855), and, I think, assuming that the number you provide to `st_set_precision()` was a 'tolerance', or, in effect a 'snap distance'. The help is also a bit roundabout, and directs you to [this page](https://locationtech.github.io/jts/javadoc/org/locationtech/jts/geom/PrecisionModel.html), for an explanation of how it works. \n\nIn effect all coordinates are adjusted by applying a function like this one:\n\n```{r}\nadjust_precision <- function(x, precision) {\n  round(x * precision) / precision\n}\nsqrt(2) %>% adjust_precision(1000)\n```\n\n### `st_snap`\nAnother possible fix for the floating point issue is snapping points to the coordinates of another object before applying operations. So this works, although it is not as clean as the `st_precision` option. On the other hand, it does work on plain geometry objects, not only on those that have been bundled up into collections.\n\n```{r}\ns1 %>% st_snap(s2, 1e-8) %>%\n  st_union(s2) %>%\n  plot()\n```\n## In conclusion\nThe tools for making and manipulating geometries at a low level are available in `sf` but they are not always as simple as you'd like. Of course, most often you are dealing with datasets and that's where `sf` comes into its own. Just remember `st_set_precision()` and you should be able to avoid quite a few headaches...\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"low-level-sf-objects.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.551","theme":"lux","title-block-banner":true,"title":"Low level handling of sf objects","description":"You can handle sf objects at a low level but it can\ntake a bit of getting used to\n","author":"David O'Sullivan","categories":["R","spatial"],"draft":false,"date":"04-02-2024"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}