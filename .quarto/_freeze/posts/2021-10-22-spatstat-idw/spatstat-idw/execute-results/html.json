{
  "hash": "aa352cafa165e73967b0ed3167524e85",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Inverse distance weighted (IDW) interpolation using spatstat\"\nauthor: David O'Sullivan\ndescription: |\n  One of the joys (ahem) of R spatial is moving data around between formats so\n  you can use the best packages for particular jobs. Here's an example using IDW\n  interpolation in spatstat\ndate: 04-02-2024\n---\n\n\n## Libraries\nLibraries are the usual suspects plus `spatstat` (duh) and `maptools` for some extra conversions. We also need `terra` for the data prep.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(dplyr)\nlibrary(tmap)\nlibrary(spatstat)\nlibrary(terra)\n```\n:::\n\n\n## Introduction\nAs is often the case there is useful functionality in a package that doesn't play nice with the core R-spatial packages. `spatstat` is really great for lots of things, but does not support `sf` and even needs a bit of persuading to handle `sp` data. Its implementation of IDW interpolation is nice however, so it's nice to know how to use it. Whether or not you should ever use IDW is another question altogether, but we can worry about that some other time.\n\n### Data\nFirst we need a set of values to interpolate. I made a projected version of the _R_ core dataset volcano which is a nice place to start.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaungawhau <-  rast(\"maungawhau.tif\")\n```\n:::\n\n\n### Some random control points and a study area\nWe can get a dataframe of random points on the surface using `terra::spatSample`. We'll make this into a `sf` object as a starting point because that's the most likely situation when you want to interpolate data (you will have an `sf` source).\n\n\n::: {.cell}\n\n```{.r .cell-code}\npts <- maungawhau |>\n  spatSample(500, xy = TRUE) |>\n  st_as_sf(coords = c(\"x\", \"y\")) |>\n  st_set_crs(2193) |>\n  st_jitter(5)\n```\n:::\n\n\nWe also need a spatial extent for the interpolation, so let's just make a convex hull of the points\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspatial_extent <- pts |>\n  st_union() |>\n  st_convex_hull() |>\n  st_sf()\n```\n:::\n\n\nAnd just to see where we are at\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(maungawhau) + \n  tm_raster() +\n  tm_shape(pts) + \n  tm_dots() + \n  tm_shape(spatial_extent) + \n  tm_borders() + \n  tm_layout(legend.outside = TRUE)\n```\n\n::: {.cell-output-display}\n![](spatstat-idw_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n## Make the data into a `spatstat` point pattern\n`spatstat` has its own format for point patterns, including coordinates, marks (the values) and a window or `owin` (the spatial extent). It's best to make the window first and then we can make the whole thing all at once. `spatstat` prefers `sp` objects, so we go via 'Spatial' to get a `spatstat::owin` object. `maptools` provides the conversion to an `owin`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nW <- spatial_extent |>\n  as.owin()\n```\n:::\n\n\nWe also need the control point coordinates\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxy <- pts |>\n  st_coordinates() |>\n  as_tibble()\n```\n:::\n\n\nNow we can make a `spatstat::ppp` point pattern\n\n\n::: {.cell}\n\n```{.r .cell-code}\npp <- ppp(x = xy$X, xy$Y, marks = pts$maungawhau, window = W)\nplot(pp)\n```\n\n::: {.cell-output-display}\n![](spatstat-idw_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nSuccess! \n\nA [previous notebook](../2021-10-21-kde/) showed an even quicker way to do this, but where the window will be formed from a bounding box (and where's the fun in that?)\n\n```\npts %>%\n  as(\"Spatial\") %>%\n  as.ppp()\n```\n\n## Interpolation\nIt's easy from here. `power` is the inverse power applied to distances, and `eps` is the resolution in units of the coordinate system.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- idw(pp, power = 2, eps = 10)\nplot(result)\n```\n\n::: {.cell-output-display}\n![](spatstat-idw_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nThis is readily converted back to a `terra` raster for comparison with the original surface.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninterpolation <- rast(result)\ncrs(interpolation) <- crs(maungawhau) # spatstat does not retain CRS information\n\nm1 <- tm_shape(maungawhau) + \n  tm_raster()\nm2 <- tm_shape(interpolation) +\n  tm_raster()\n\ntmap_arrange(m1, m2)\n```\n\n::: {.cell-output-display}\n![](spatstat-idw_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nLike I said, IDW is not necessarily a great interpolation method!\n\n",
    "supporting": [
      "spatstat-idw_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}