{
  "hash": "ee1eef72e11f03366f697c211a10ea80",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Low level handling of sf objects\"\ndescription: |\n  You can handle sf objects at a low level but it can \n  take a bit of getting used to\ndate: 12-08-2021\ndraft: false\noutput:\n  distill::distill_article\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::opts_chunk$set(error = TRUE, message = TRUE)\n```\n:::\n\n\n## Packages\nEverything here needs just `sf` and `dplyr`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(dplyr)\n```\n:::\n\n\n## Making polygons\nMy main confusion dealing with polygons in `sf` sounds dumb, but was easily fixed. Matrices in *R* get populated by column, by default, where the points in a polygon are in the rows of the matrix (as they would be in a dataframe with x and y attributes). You just have to make sure to populate the matrices in the right order. \n\nThere's also the slightly strange fact that you have to wrap a matrix of points in a list to make a polygon. \n\nSo because of the row-column thing, there's a tendency to do\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- matrix(c(0, 0,\n                1, 0,\n                1, 1,\n                0, 1,\n                0, 0), nrow = 5, ncol = 2)\nsquare <- st_polygon(list(mat))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in MtrxSet(x, dim, type = \"POLYGON\", needClosed = TRUE): polygons not (all) closed\n```\n\n\n:::\n:::\n\n\nBut that fails, because the matrix we made was\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    0    1\n[2,]    0    0\n[3,]    1    1\n[4,]    0    0\n[5,]    1    0\n```\n\n\n:::\n:::\n\n\nand the first and last rows don't match (even if they did, it's not actually a polygon!).\n\nBut specify that the matrix should be populated `byrow` and all is well\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare <- st_polygon(list(matrix(c(0, 0,\n                                   1, 0,\n                                   1, 1,\n                                   0, 1,\n                                   0, 0), nrow = 5, ncol = 2, byrow = TRUE)))\nplot(square)\n```\n\n::: {.cell-output-display}\n![](low-level-sf-objects_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nIf you happen to have vectors of the x and y coordinates, then it's easier.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(0, 1, 1, 0, 0)\ny <- c(0, 0, 1, 1, 0)\nsquare <- st_polygon(list(matrix(c(x, y), nrow = 5, ncol = 2)))\nplot(square)\n```\n\n::: {.cell-output-display}\n![](low-level-sf-objects_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n## Floating point coordinates and their discontents\n`sf` defaults to using floating point calculations which has some annoying side-effects. For example, the code below results in an error\n\n\n::: {.cell}\n\n```{.r .cell-code}\nangles <- 0:3 * 2 * pi / 3\nx <- cos(angles)\ny <- sin(angles)\ntriangle <- st_polygon(list(matrix(c(x, y), nrow = 7, ncol = 2)))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in matrix(c(x, y), nrow = 7, ncol = 2): data length [8] is not a\nsub-multiple or multiple of the number of rows [7]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-error}\n\n```\nError in MtrxSet(x, dim, type = \"POLYGON\", needClosed = TRUE): polygons not (all) closed\n```\n\n\n:::\n:::\n\n\nBecause `sf` defaults to floating point it doesn't consider the polygon closed due to precision issues that mean *R* considers `sin(0) != sin(2 * pi)`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsin(0) == sin(2 * pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\nThere is no easy way to fix this except to round the coordinates!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- round(x, 6)\ny <- round(y, 6)\ntriangle <- st_polygon(list(matrix(c(x, y), nrow = 4, ncol = 2)))\nplot(triangle)\n```\n\n::: {.cell-output-display}\n![](low-level-sf-objects_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nThere's not a lot you can do about this when you are constructing `sf` objects. Polygons must be closed, and equality is strictly applied to the opening and closing points. You can't ask `st_polygon` to automatically close polygons for you.\n\nOnce you have polygons to work with, the problem can come back to bite you, but there is a way around it. For example, this works OK:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare %>% \n  st_difference(triangle) %>%\n  plot()\n```\n\n::: {.cell-output-display}\n![](low-level-sf-objects_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nBut let's make two squares that are _theoretically_ adjacent to one another, but happen to have non-integer coordinates (which... is pretty commonplace!)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nangles <- seq(1, 7, 2) * 2 * pi / 8\nangles <- c(angles, angles[1])\nx1 <- cos(angles)\ny1 <- sin(angles)\n\ns1 <- st_polygon(list(matrix(c(x1, y1), nrow = 5, ncol = 2)))\nbb <- st_bbox(s1)\ns2 <- s1 + c(bb$xmax - bb$xmin, 0)\n\nplot(s1, xlim = c(-1, 2.1))\nplot(s2, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](low-level-sf-objects_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nTwo squares, next to one another as we might hope, but if, for example, we `st_union` them we get a MULTIPOLYGON.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns3 <- st_union(s1, s2)\ns3\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nMULTIPOLYGON (((0.7071068 0.7071068, -0.7071068 0.7071068, -0.7071068 -0.7071068, 0.7071068 -0.7071068, 0.7071068 0.7071068)), ((2.12132 0.7071068, 0.7071068 0.7071068, 0.7071068 -0.7071068, 2.12132 -0.7071068, 2.12132 0.7071068)))\n```\n\n\n:::\n:::\n\n\nIf we plot them, they still appear separate\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(s3)\n```\n\n::: {.cell-output-display}\n![](low-level-sf-objects_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nand if we measure the distance between them, turns out they don't touch at all, but are in fact a miniscule distance apart...\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns1 %>% st_distance(s2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             [,1]\n[1,] 3.330669e-16\n```\n\n\n:::\n:::\n\n\nIt's probably not necessary to point out how silly this is, even if it is strictly correct.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRXKCD::getXKCD(2170)$img\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in loadNamespace(x): there is no package called 'RXKCD'\n```\n\n\n:::\n:::\n\n\n\n## Specifying precision for spatial operations\nBy contrast if we use `rgeos` functions the equivalent union operation works as we might expect (although we do have to feed `rgeos` the old `sp` types of polygon, which we can do via a call to `as(\"Spatial\")`...)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrgeos::gUnion(as(s1, \"Spatial\"), as(s2, \"Spatial\")) %>%\n  st_as_sfc() %>%\n  plot()\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in loadNamespace(x): there is no package called 'rgeos'\n```\n\n\n:::\n:::\n\n\n`sf` does allow us to effectively emulate the `rgeos` behaviour, albeit not for simple geometries. When we instead bundle geometries up into feature collections, we can assign them a precision, and this will take care of the kinds of problems we see above:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns1_sfc <- s1 %>% \n  st_sfc() %>%\n  st_set_precision(1e8)\ns2_sfc <- s2 %>% \n  st_sfc() %>%\n  st_set_precision(1e8)\n\ns1_sfc %>% \n  st_union(s2_sfc) %>%\n  plot()\n```\n\n::: {.cell-output-display}\n![](low-level-sf-objects_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nThe first time I looked this up [in help](https://r-spatial.github.io/sf/reference/st_precision.html), I got it wrong [due to careless reading](https://github.com/r-spatial/sf/issues/1855), and, I think, assuming that the number you provide to `st_set_precision()` was a 'tolerance', or, in effect a 'snap distance'. The help is also a bit roundabout, and directs you to [this page](https://locationtech.github.io/jts/javadoc/org/locationtech/jts/geom/PrecisionModel.html), for an explanation of how it works. \n\nIn effect all coordinates are adjusted by applying a function like this one:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadjust_precision <- function(x, precision) {\n  round(x * precision) / precision\n}\nsqrt(2) %>% adjust_precision(1000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.414\n```\n\n\n:::\n:::\n\n\n### `st_snap`\nAnother possible fix for the floating point issue is snapping points to the coordinates of another object before applying operations. So this works, although it is not as clean as the `st_precision` option. On the other hand, it does work on plain geometry objects, not only on those that have been bundled up into collections.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns1 %>% st_snap(s2, 1e-8) %>%\n  st_union(s2) %>%\n  plot()\n```\n\n::: {.cell-output-display}\n![](low-level-sf-objects_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n## In conclusion\nThe tools for making and manipulating geometries at a low level are available in `sf` but they are not always as simple as you'd like. Of course, most often you are dealing with datasets and that's where `sf` comes into its own. Just remember `st_set_precision()` and you should be able to avoid quite a few headaches...\n",
    "supporting": [
      "low-level-sf-objects_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}