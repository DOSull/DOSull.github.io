{
  "hash": "6a98bdf1438092bc67d8ac06672ff0d1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Affine transformations of sf objects\"\ndescription: |\n  Manipulating simple features in `sf` is sorta simple, sorta not...\ndate: 12-16-2021\ndraft: false\noutput:\n  distill::distill_article\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::opts_chunk$set(error = TRUE, message = TRUE)\n```\n:::\n\n\n## Packages\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(tmap)\nlibrary(dplyr)\nlibrary(wk)\n\nsf::sf_use_s2(FALSE)\n```\n:::\n\n\n## A simple square\nJust to get things set up let's make a simple square.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare <- (st_polygon(list(matrix(c(-1, -1, 1, -1, 1, 1, -1, 1, -1, -1), \n                                 5, 2, byrow = TRUE))) * 0.5 + c(1, 0)) %>%\n  st_sfc()\n\ntm_shape(square) + \n  tm_borders(col = \"red\") + \n  tm_grid()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Currect projection of shape square unknown. Long-lat (WGS84) is\nassumed.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](affine-transformations-of-sf-objects_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n## Simple transformations\nIn the code above, we made a polygon and multipled it by 0.5, then added `c(1,0)` to it. This had the effect of scaling it by 0.5 andthen translating it by the vector $$\\left[\\begin{array}{c}1\\\\0\\end{array}\\right]$$\n\nThese unlikely looking operations are [perfectly valid](https://r-spatial.github.io/sf/articles/sf3.html#affine-transformations), although they feel a bit 'off'.\n\nEven more unlikely is that you can _multiply an `sf` object by a matrix_...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nang <- pi / 6\nmat <- matrix(c(cos(ang), -sin(ang), \n                sin(ang),  cos(ang)), 2, 2, byrow = TRUE)\n(square * mat) %>% \n  plot()\n```\n\n::: {.cell-output-display}\n![](affine-transformations-of-sf-objects_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nThis is very handy... but probably also a bad idea! Because you have to post-multiply by the matrix, the sense of many [affine transformations](https://en.wikipedia.org/wiki/Affine_transformation) is reversed and construction of the matrix is not 'by the book'. _Usually_ the affine transformation matrix $\\mathbf{A}$ for an anti-clockwise rotation by angle $\\theta$ around the origin, would be\n\n$$\n\\mathbf{A} = \n\\left[\\begin{array}{cc}\n\\cos\\theta & -\\sin\\theta \\\\\n\\sin\\theta & \\cos\\theta\n\\end{array}\\right]\n$$\n\nHere, because we are post-multiplying the rotation will be in the other direction... and to rotate anti-clockwise, you use the $-\\mathbf{A}=\\mathbf{A}^T$\n\n$$\n-\\mathbf{A} = \n\\left[\\begin{array}{cc}\n-\\cos\\theta & \\sin\\theta \\\\\n-\\sin\\theta & -\\cos\\theta\n\\end{array}\\right] = \n\\left[\\begin{array}{cc}\n\\cos\\theta & \\sin\\theta \\\\\n-\\sin\\theta & \\cos\\theta\n\\end{array}\\right] = \\mathbf{A}^\\mathrm{T}\n$$\n \nThis means that if you are doing any serious affine transforming of `sf` shapes at a low-level in R spatial, I  recommend either writing some wrapper functions that generate and apply the necessary matrices on the fly, or, probably better yet, using the [`wk` package](https://paleolimbot.github.io/wk/) which has proper support for affine transformations. \n\n# Wrapper functions for the 'native' matrix operations\nTaking the `wk` approach, I will show what you can do below. Making similar functions that just post-multiply shapes or add vectors to them instead is left as an exercise for the reader...\n\nFor example a rotation function might look something like\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrotate_sf <- function(shp, angle) {\n  wk::wk_transform(shp, wk::wk_affine_rotate(angle))\n}\n```\n:::\n\n\nand this can be applied like this\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_s <- st_polygon(list(matrix(c(.25, 0.25, \n                                   1.5, 0.25, \n                                   1.5, 1.5, \n                                   .25, 1.5, \n                                   .25, .25), \n                                 nrow = 5, ncol = 2, byrow = TRUE)))\nplot(base_s, xlim = c(-2, 2), ylim = c(-2, 2), \n     col = \"lightgrey\", border = NA)\nfor (a in seq(0, 330, 30)) {\n  plot(rotate_sf(base_s, a), add = TRUE)\n}\n```\n\n::: {.cell-output-display}\n![](affine-transformations-of-sf-objects_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nOr you might want to make multiple copies of a basic unit at a series of locations on a grid. First, make a function that will translate a shape by a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntranslate_shape <- function(shape, translation) {\n  wk::wk_transform(shape, wk::wk_affine_translate(translation[1], translation[2]))\n}\n```\n:::\n\n\nGenerate a set of translations\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid <- expand.grid(x = 0:19 * 1.2 + 1, y = 0:19 * 1.2 + 1)\nsquares <- list()\nfor (i in seq(nrow(grid))) {\n  squares <- append(squares, \n                    list(translate_shape(square, c(grid$x[i], grid$y[i]))))\n}\nsquares %>% sapply(\"[\") %>% st_sfc() %>%\n  plot()\n```\n\n::: {.cell-output-display}\n![](affine-transformations-of-sf-objects_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\nThe `wk` functions also allow you to compose complex transformations from several steps. For example a function to rotate a shape around its own centre, i.e., not around the origin at $(0,0)$ requires moving the shape so that its centroid is at the origin, performing the rotation, then moving it back:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrotate_around_centroid <- function(shape, angle) {\n  centroid <- st_centroid(shape) %>%\n    st_coordinates() %>%\n    c()\n  transformation <- wk::wk_affine_compose(\n    wk::wk_affine_translate(-centroid[1], -centroid[2]),\n    wk::wk_affine_rotate(angle),\n    wk::wk_affine_translate(centroid[1], centroid[2])\n  )\n  wk::wk_transform(shape, transformation)\n}\n```\n:::\n\n\nAnd here's that in action\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(square, xlim = c(-1, 1), ylim = c(-1, 1))\nfor (a in seq(30, 90, 30)) {\n  plot(rotate_around_centroid(square, a), add = TRUE)\n}\n```\n\n::: {.cell-output-display}\n![](affine-transformations-of-sf-objects_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "affine-transformations-of-sf-objects_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}